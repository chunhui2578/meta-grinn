diff -rupN linux-orig/sound/soc/davinci/davinci-evm.c linux-gisbc/sound/soc/davinci/davinci-evm.c
--- linux-orig/sound/soc/davinci/davinci-evm.c	2012-11-09 16:19:09.000000000 +0100
+++ linux-gisbc/sound/soc/davinci/davinci-evm.c	2013-01-02 12:34:01.321760206 +0100
@@ -31,6 +31,10 @@
 
 #define AUDIO_FORMAT (SND_SOC_DAIFMT_DSP_B | \
 		SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_IB_NF)
+
+#define GISBC_AUDIO_FORMAT (SND_SOC_DAIFMT_DSP_B | \
+		SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_IB_NF)
+
 static int evm_hw_params(struct snd_pcm_substream *substream,
 			 struct snd_pcm_hw_params *params)
 {
@@ -40,6 +44,8 @@ static int evm_hw_params(struct snd_pcm_
 	int ret = 0;
 	unsigned sysclk;
 
+	printk(KERN_ERR "========== evm ========== davinci-evm.c: evm_hw_params\n");
+
 	/* ASP1 on DM355 EVM is clocked by an external oscillator */
 	if (machine_is_davinci_dm355_evm() || machine_is_davinci_dm6467_evm() ||
 	    machine_is_davinci_dm365_evm())
@@ -57,18 +63,18 @@ static int evm_hw_params(struct snd_pcm_
 		sysclk = 24576000;
 	/* On AM335X, CODEC gets MCLK from external Xtal (12MHz). */
 	else if (machine_is_am335xevm())
-		sysclk = 12000000;
+		sysclk = 24000000;
 
 	else
 		return -EINVAL;
 
 	/* set codec DAI configuration */
-	ret = snd_soc_dai_set_fmt(codec_dai, AUDIO_FORMAT);
+	ret = snd_soc_dai_set_fmt(codec_dai, GISBC_AUDIO_FORMAT);
 	if (ret < 0)
 		return ret;
 
 	/* set cpu DAI configuration */
-	ret = snd_soc_dai_set_fmt(cpu_dai, AUDIO_FORMAT);
+	ret = snd_soc_dai_set_fmt(cpu_dai, GISBC_AUDIO_FORMAT);
 	if (ret < 0)
 		return ret;
 
@@ -155,6 +161,40 @@ static int evm_aic3x_init(struct snd_soc
 	return 0;
 }
 
+static int evm_aic32x4_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	int ret = 0;
+	unsigned sysclk;
+
+	printk(KERN_ERR "========== evm ========== davinci-evm.c: evm_aic32x4_init\n");
+
+	/* On AM335X, CODEC gets MCLK from external Xtal (12MHz). */
+	if (machine_is_am335xevm())
+		sysclk = 24000000;
+	else
+		return -EINVAL;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, GISBC_AUDIO_FORMAT);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, GISBC_AUDIO_FORMAT);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, sysclk, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
 /* davinci-evm digital audio interface glue - connects codec <--> CPU */
 static struct snd_soc_dai_link dm6446_evm_dai = {
 	.name = "TLV320AIC3X",
@@ -242,13 +282,14 @@ static struct snd_soc_dai_link da850_evm
 };
 
 static struct snd_soc_dai_link am335x_evm_dai = {
-	.name = "TLV320AIC3X",
-	.stream_name = "AIC3X",
+	.name = "tlv320aic32x4",
+	.stream_name = "TLV320AIC32X4",
 	.cpu_dai_name = "davinci-mcasp.0",
-	.codec_dai_name = "tlv320aic3x-hifi",
-	.codec_name = "tlv320aic3x-codec.3-001b",
+	.codec_dai_name = "tlv320aic32x4-hifi",
+//	.codec_name = "tlv320aic3x-codec.3-001b",
+	.codec_name = "tlv320aic32x4.1-0018",
 	.platform_name = "davinci-pcm-audio",
-	.init = evm_aic3x_init,
+	.init = evm_aic32x4_init,
 	.ops = &evm_ops,
 };
 
@@ -306,6 +347,8 @@ static int __init evm_init(void)
 	int index;
 	int ret;
 
+	printk(KERN_ERR "========== evm ========== davinci-evm.c: evm_init\n");
+
 	if (machine_is_davinci_evm()) {
 		evm_snd_dev_data = &dm6446_snd_soc_card_evm;
 		index = 0;
@@ -325,6 +368,8 @@ static int __init evm_init(void)
 		evm_snd_dev_data = &da850_snd_soc_card;
 		index = 0;
 	} else if (machine_is_am335xevm()) {
+		printk(KERN_ERR "========== evm ========== davinci-evm.c: evm_init -> machine_is_am335xevm\n");
+
 		evm_snd_dev_data = &am335x_snd_soc_card;
 		index = 0;
 	} else
@@ -332,13 +377,16 @@ static int __init evm_init(void)
 
 	evm_snd_device = platform_device_alloc("soc-audio", index);
 	if (!evm_snd_device) {
+		printk(KERN_ERR "========== evm ========== davinci-evm.c: ENOMEM\n");
 		return -ENOMEM;
 	}
 
 	platform_set_drvdata(evm_snd_device, evm_snd_dev_data);
 	ret = platform_device_add(evm_snd_device);
-	if (ret)
+	if (ret) {
+		pr_err("========== evm ========== davinci-evm.c: ret=%d", ret);
 		platform_device_put(evm_snd_device);
+	}
 
 	return ret;
 }
diff -rupN linux-orig/sound/soc/davinci/davinci-mcasp.c linux-gisbc/sound/soc/davinci/davinci-mcasp.c
--- linux-orig/sound/soc/davinci/davinci-mcasp.c	2012-11-09 16:16:08.000000000 +0100
+++ linux-gisbc/sound/soc/davinci/davinci-mcasp.c	2013-01-02 09:51:46.521488674 +0100
@@ -334,7 +334,7 @@ static inline void mcasp_set_ctl_reg(voi
 	}
 
 	if (i == 1000 && ((mcasp_get_reg(regs) & val) != val))
-		printk(KERN_ERR "GBLCTL write error\n");
+		printk(KERN_ERR "========= mcasp ========= GBLCTL write error\n");
 }
 
 static void mcasp_start_rx(struct davinci_audio_dev *dev)
@@ -459,6 +459,10 @@ static int davinci_mcasp_set_dai_fmt(str
 	struct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
 	void __iomem *base = dev->base;
 
+	printk(KERN_ERR "========= mcasp ========= davinci-mcasp.c: davinci_mcasp_set_dai_fmt\n");
+
+	DAVINCI_MCASP_RXFMCTL_REG;
+
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
 	case SND_SOC_DAIFMT_CBS_CFS:
 		/* codec is clock and frame slave */
@@ -494,6 +498,9 @@ static int davinci_mcasp_set_dai_fmt(str
 
 		mcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG,
 				ACLKX | AHCLKX | AFSX | ACLKR | AHCLKR | AFSR);
+		// Zmiana
+		mcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,
+				AHCLKX);
 		break;
 
 	default:
@@ -546,6 +553,8 @@ static int davinci_config_channel_size(s
 	u32 fmt = 0;
 	u32 mask, rotate;
 
+	pr_err("========= mcasp ========= davinci-mcasp.c: davinci_config_channel_size %d\n", channel_size);
+
 	switch (channel_size) {
 	case DAVINCI_AUDIO_WORD_8:
 		fmt = 0x03;
@@ -685,6 +694,8 @@ static void davinci_hw_param(struct davi
 	int i, active_slots;
 	u32 mask = 0;
 
+	printk(KERN_ERR "========= mcasp ========= davinci-mcasp.c: davinci_hw_param, stream=%d\n", stream);
+
 	active_slots = (dev->tdm_slots > 31) ? 32 : dev->tdm_slots;
 	for (i = 0; i < active_slots; i++)
 		mask |= (1 << i);
@@ -697,13 +708,13 @@ static void davinci_hw_param(struct davi
 		mcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,
 				AHCLKXE);
 		mcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, mask);
-		mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXORD);
+		mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXORD);				// MSB first
 
 		if ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))
 			mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,
 					FSXMOD(dev->tdm_slots), FSXMOD(0x1FF));
 		else
-			printk(KERN_ERR "playback tdm slot %d not supported\n",
+			printk(KERN_ERR "========= mcasp ========= playback tdm slot %d not supported\n",
 				dev->tdm_slots);
 
 		mcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);
@@ -719,7 +730,7 @@ static void davinci_hw_param(struct davi
 			mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG,
 					FSRMOD(dev->tdm_slots), FSRMOD(0x1FF));
 		else
-			printk(KERN_ERR "capture tdm slot %d not supported\n",
+			printk(KERN_ERR "========= mcasp ========= capture tdm slot %d not supported\n",
 				dev->tdm_slots);
 
 		mcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);
@@ -770,6 +781,8 @@ static int davinci_mcasp_hw_params(struc
 	int word_length;
 	u8 fifo_level;
 
+	pr_err("========= mcasp ========= davinci-mcasp.c: davinci_mcasp_hw_params\n");
+
 	davinci_hw_common_param(dev, substream->stream);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		fifo_level = dev->txnumevt;
@@ -801,7 +814,7 @@ static int davinci_mcasp_hw_params(struc
 		break;
 
 	default:
-		printk(KERN_WARNING "davinci-mcasp: unsupported PCM format");
+		printk(KERN_WARNING "========= mcasp ========= davinci-mcasp: unsupported PCM format");
 		return -EINVAL;
 	}
 
diff -rupN linux-orig/sound/soc/davinci/Kconfig linux-gisbc/sound/soc/davinci/Kconfig
--- linux-orig/sound/soc/davinci/Kconfig	2012-11-09 16:16:08.000000000 +0100
+++ linux-gisbc/sound/soc/davinci/Kconfig	2012-12-17 14:44:51.107030049 +0100
@@ -41,6 +41,14 @@ config  SND_AM335X_SOC_EVM
 	help
 	  Say Y if you want to add support for SoC audio on
 	  AM335X EVM
+	  
+config SND_AM335X_SOC_GISBC
+	tristate "SoC Audio support for GISBC"
+	depends on SND_AM33XX_SOC
+	select SND_DAVINCI_SOC_MCASP
+	select SND_SOC_TLV320AIC32X4
+	help
+	  Say Y if you want to add support for SoC audio in GISBC
 
 choice
 	prompt "DM365 codec select"
diff -rupN linux-orig/sound/soc/davinci/Makefile linux-gisbc/sound/soc/davinci/Makefile
--- linux-orig/sound/soc/davinci/Makefile	2012-11-09 16:16:08.000000000 +0100
+++ linux-gisbc/sound/soc/davinci/Makefile	2012-12-17 12:48:40.478835620 +0100
@@ -19,4 +19,5 @@ obj-$(CONFIG_SND_DM6467_SOC_EVM) += snd-
 obj-$(CONFIG_SND_DA830_SOC_EVM) += snd-soc-evm.o
 obj-$(CONFIG_SND_DA850_SOC_EVM) += snd-soc-evm.o
 obj-$(CONFIG_SND_AM335X_SOC_EVM) += snd-soc-evm.o
+obj-$(CONFIG_SND_AM335X_SOC_GISBC) += snd-soc-evm.o
 obj-$(CONFIG_SND_DAVINCI_SOC_SFFSDR) += snd-soc-sffsdr.o
